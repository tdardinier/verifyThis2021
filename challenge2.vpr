// Ref is the type of nodes used for both list and tree, and has these fields:
field data: Int
field prev: Ref // Also used as left subtree pointer
field next: Ref // Also used as right subtree pointer

predicate list(head: Ref) {
    head != null ==>
        acc(head.data) && acc(head.prev) && acc(head.next) && list(head.next)
}


predicate dll(head: Ref) {
    head != null ==>
        acc(head.data) && acc(head.prev) && acc(head.next) &&
        dll(head.prev) && dll(head.next)
}

// only needs forward access
method size(head: Ref) returns (count: Int)
    requires list(head)
    ensures list(head)
    ensures count == size_list(head)
{
    if (head != null) {
        unfold list(head)
        count := size(head.next)
        count := count + 1
        fold list(head)
    } else {
        count := 0
    }
}

function size_list(head: Ref): Int
    requires list(head)
    ensures result >= 0
{
    head != null ? (unfolding list(head) in size_list(head.next) + 1) : 0
}

method lemma_size_non_null_non_empty(head: Ref)
    requires list(head)
    requires size_list(head) > 0
    ensures list(head) && head != null
{
}

method dll_to_bst(head: Ref) returns (root: Ref)
    requires list(head)
    ensures bst(root)
{
    var n: Int
    var right: Ref
    n := size(head)
    root, right := dll_to_bst_rec(head, n)

    assert bst(root) && list(right)

}

// Converts a sorted DLL into a balanced BST
// head: Pointer to doubly linked list
// n: number of nodes of list to convert to tree

predicate bst(root: Ref) {
    root != null ==>
        acc(root.data) && acc(root.prev) && acc(root.next) &&
        bst(root.prev) && bst(root.next)
}

function size_bst(root: Ref): Int
    requires bst(root)
{
    root != null ? (unfolding bst(root) in size_bst(root.next) + size_bst(root.prev) + 1) : 0
}

function list_larger(head: Ref, m: Int): Bool
    requires list(head)
{
    head != null ==> unfolding list(head) in head.data >= m && list_larger(head.next, m)
}

function sorted_list(head: Ref): Bool
    requires list(head)
{
    head != null ==> list_larger(head, unfolding list(head) in head.data) && unfolding list(head) in sorted_list(head.next)
}

function bst_smaller_than(root: Ref, M: Int): Bool
    requires acc(bst(root), 1/2)
{
    root != null ==>
        unfolding acc(bst(root), 1/2) in root.data <= M && bst_smaller_than(root.prev, M) && bst_smaller_than(root.next, M)
}

function bst_larger_than(root: Ref, m: Int): Bool
    requires acc(bst(root), 1/2)
{
    root != null ==>
        unfolding acc(bst(root), 1/2) in root.data >= m && bst_larger_than(root.prev, m) && bst_larger_than(root.next, m)
}

function is_bst(root: Ref): Bool
    requires acc(bst(root), 1/2)
{
    root != null ==>
        unfolding acc(bst(root), 1/2) in
            bst_smaller_than(root.prev, root.data) && bst_larger_than(root.next, root.data) &&
            is_bst(root.prev) && is_bst(root.next)
}

method lemma_bst_larger_than_change_bound(root: Ref, a: Int, b: Int)
    requires acc(bst(root), 1/2)
    requires bst_larger_than(root, a)
    requires a >= b
    ensures acc(bst(root), 1/2)
    ensures bst_larger_than(root, b)
{
    if (root != null) {
        unfold acc(bst(root), 1/2)
        assert root.data >= a
        assert bst_larger_than(root.prev, a)
        lemma_bst_larger_than_change_bound(root.prev, a, b)
        assert bst_larger_than(root.next, a)
        lemma_bst_larger_than_change_bound(root.next, a, b)
        fold acc(bst(root), 1/2)
    }
}

method lemma_bst_smaller_than_change_bound(root: Ref, a: Int, b: Int)
    requires acc(bst(root), 1/2)
    requires bst_smaller_than(root, a)
    requires a <= b
    ensures acc(bst(root), 1/2)
    ensures bst_smaller_than(root, b)
{
    if (root != null) {
        unfold acc(bst(root), 1/2)
        assert root.data <= a
        assert bst_smaller_than(root.prev, a)
        lemma_bst_smaller_than_change_bound(root.prev, a, b)
        assert bst_smaller_than(root.next, a)
        lemma_bst_smaller_than_change_bound(root.next, a, b)
        fold acc(bst(root), 1/2)
    }

}


method dll_to_bst_rec(head: Ref, n: Int) returns (root: Ref, right: Ref)
    requires list(head)

    requires size_list(head) >= n
    requires n >= 0

    ensures list(right)
    ensures bst(root)
    ensures size_bst(root) == n
    ensures size_list(right) + n == old(size_list(head))
    ensures old(sorted_list(head)) ==> sorted_list(right) && is_bst(root)

    // The bst is smaller than the element on the right, that is right.data
    ensures old(sorted_list(head)) && right != null ==> unfolding list(right) in bst_smaller_than(root, right.data)
    // The bst is larger than the element on the left, that is head.data
    ensures old(sorted_list(head)) && head != null ==> bst_larger_than(root, old(unfolding list(head) in head.data))

    ensures old(sorted_list(head)) && root != null && right != null ==> (unfolding bst(root) in root.data) <= (unfolding list(right) in right.data)
    ensures old(sorted_list(head)) && root != null && head != null ==> (old(unfolding list(head) in head.data)) <= (unfolding bst(root) in root.data)
    ensures old(sorted_list(head)) && right != null && head != null ==> (old(unfolding list(head) in head.data)) <= (unfolding list(right) in right.data)

    ensures head == null ==> root == null
    
{
    var b: Bool := old(sorted_list(head))

    if (n > 0) {
        // Recursively construct the left subtree
        var left: Ref
        left, root := dll_to_bst_rec(head, n/2)
        // [head, root) is a tree rooted at left, [root, ...] is a list
        // Set pointer to left subtree

        // Termination:
        assert n/2 < n
        assert n >= 0

        var v_root: Int := unfolding list(root) in root.data
        var v_head: Int := old(unfolding list(head) in head.data)

        assert b && root != null && head != null ==> v_root >= v_head
        assert b && right != null ==> bst_smaller_than(left, v_root)
        assert b && head != null ==> bst_larger_than(left, v_head)


        assert size_bst(left) == n/2
        assert bst(left) && list(root)

        assert b ==> sorted_list(root) && is_bst(left)

        assert b ==> sorted_list(root)

        unfold list(root)

        
        assert b ==>  sorted_list(root.next)

        // Needs access to root.prev
        root.prev := left

        // Recursively construct the right subtree
        // size(right subtree) = n - size(left subtree) - 1 (for root)
        var temp: Ref

        label before_second_call
        
        temp, right := dll_to_bst_rec(root.next, n-n/2-1)

        var old_root_next: Ref := root.next

        var v_root_next: Int
        if (root.next != null) {
            v_root_next := old[before_second_call](unfolding list(root.next) in root.next.data)
        }
        else {
            v_root_next := v_root
            assert temp == null
            assert bst_larger_than(temp, v_root_next)
        }

        assert old[before_second_call](sorted_list(root.next)) && root.next != null
            ==> bst_larger_than(temp, v_root_next)

        assert b && old_root_next != null ==> bst_larger_than(temp, v_root_next)


    


        var v_right: Int
        if (right != null) {
            v_right := unfolding list(right) in right.data
        }

        assert b && root.next != null ==> bst_larger_than(temp, v_root_next)

 

        // Termination:
        assert n - n/2 - 1 < n
        assert n >= 0


        assert size_bst(temp) == n-n/2-1
        assert bst(temp) && list(right)

        assert b ==> sorted_list(right) && is_bst(temp)


        assert b ==> is_bst(left) && is_bst(temp)

        assert b && root.next != null ==> bst_larger_than(temp, v_root_next)



        assert b && root.next != null ==> bst_larger_than(temp, v_root_next)

        // [head, root) is a tree rooted at left, [root.next, right) is tree at temp
        // Set pointer to right subtree
        root.next := temp
        // [head, right) is a tree rooted at root

        //assert b && root.next != null ==> bst_larger_than(temp, v_root_next)




        assert b && head != null ==> bst_larger_than(left, v_head)

        assert b ==> is_bst(root.prev)
        assert b ==> is_bst(root.next)

        assert b ==> bst_smaller_than(root.prev, root.data)
        if (b && root.next != null) {

            assert b && old_root_next != null ==> bst_larger_than(temp, v_root_next)
            assert old_root_next != null ==> bst_larger_than(root.next, v_root_next)


            assert head != null ==> bst_larger_than(temp, v_root_next)

            assert v_root <= v_root_next

            lemma_bst_larger_than_change_bound(root.next, v_root_next, v_root)
            assert bst_larger_than(root.next, v_root)
        }


        assert b && right != null ==> bst_smaller_than(left, v_root) && bst_smaller_than(temp, v_right)

        if (b && right != null) {
            assert bst_smaller_than(root.prev, v_root)
            assert bst_smaller_than(temp, v_right)

            assert v_right >= v_root

            lemma_bst_smaller_than_change_bound(root.prev, v_root, v_right)
        }

        if (b && head != null) {
            // root.prev = left
            // root.next = temp


            assert bst_larger_than(root.prev, v_head)

            assert root.next != null ==> bst_larger_than(root.next, v_root_next)

            assert root != null ==> v_root >= v_head
            assert v_root_next >= v_head

            lemma_bst_larger_than_change_bound(root.next, v_root_next, v_head)

        }
        fold bst(root)



        assert old(sorted_list(head)) ==> sorted_list(right) && is_bst(root)


        assert size_bst(root) == n/2 + n - n/2
        assert size_bst(root) == n

    } else {
        root := null
        right := head
        fold bst(root)

        assert old(sorted_list(head)) && right != null ==> unfolding list(right) in bst_smaller_than(root, right.data)
    }
}