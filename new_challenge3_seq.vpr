import <decreases/int.vpr>

// Tasks completed: 1 and 2

// Carbon ~ 12 s
// Silicon fails to verify it

// nxn matrix on heap

domain NMatrix {
  function slot(a: NMatrix, i: Int, j:Int): Ref
  function dim(a: NMatrix): Int
  function parent(r: Ref): NMatrix
  function Icoord(r: Ref): Int
  function Jcoord(r: Ref): Int

  axiom all_diff { // slot(m,i,j) is injective in all parameters
    forall m: NMatrix, i: Int, j:Int :: { slot(m,i,j) }
      parent(slot(m,i,j)) == m && Icoord(slot(m,i,j)) == i && Jcoord(slot(m,i,j)) == j 
  }

  axiom dim_nonneg {
    forall a: NMatrix :: { dim(a) }
      dim(a) >= 0
  }

}

// CODE

field val: Int // heap location per slot per matrix

method sort_row(m: NMatrix, row: Int, ascending: Bool)
  requires access_row(m, row)
  requires row >= 0 && row < dim(m)
  ensures access_row(m, row)
  ensures repRow(m, row, 0) == old(repRow(m, row, 0))
  //TOSEQ: ensures rowSorted(S, row, even(row))

method sort_column(m: NMatrix, column: Int)
  requires access_column(m, column)
  requires column >= 0 && column < dim(m)
  ensures access_column(m, column)
  ensures repCol(m, 0, column) == old(repCol(m, 0, column))

method shearsort(n: Int, m: NMatrix)
  requires access_matrix(m)
  requires dim(m) == n
  ensures access_matrix(m)
  ensures repByRows(m, 0, 0) == old(repByRows(m, 0, 0)) // Permutation
{

  helper_lemma(m, 0, 1/2)

  assert old(repByRows(m, 0, 0)) == old(repByCols(m, 0, 0))


  var k: Int // uninitialised - represents an "arbitrary bound" with respect to sorting properties proven
  var p: Int := 0

  // i < ceil(log2(n)) + 1
  // <=> i < log2(n) + 1
  // <=> i - 1 < log2(n)
  // <=> 2^(i - 1) < n
  // <=> two_exponent(i - 1) < n
  // <=> two_exponent(i) < 2*n // avoids evaluating for 
  while (two_exponent(p) < 2*n)
    invariant p >= 0
    invariant access_matrix(m)
    invariant repByRows(m, 0, 0) == old(repByRows(m, 0, 0))
    invariant repByCols(m, 0, 0) == old(repByCols(m, 0, 0))

    decreases 2*n - two_exponent(p) // task 1: Termination (memory safety is implicit with permissions)
    //invariant forall r: Int :: 0 <= r && r < rowsLessThanK ==> // all values are <= k
    //invariant forall r: Int :: rowsGtK <= r && r < dim(m) ==> // all values are >= k
  {

    label before1

    // First inner parallel loop
    // Corresponds to forking n threads (per tid instance): the exhales model transfer of heap ownership && value info per thread
    exhale forall tid:Int :: { repRow(m, tid, 0) } tid >= 0 && tid < n ==> P1(m, tid)
    // The corresponding loop body is checked in a separate Viper "method" first_inner_loop below
    // Corresponds to joining n threads (per tid instance): the inhales model transfer of heap ownership && value info per thread
    inhale forall tid:Int :: { repRow(m, tid, 0) } {even(tid)} tid >= 0 && tid < n ==> Q1(m, tid, before1)

    // Sorted by rows
    //TOSEQ: assert sortedRows(m)


    // Ghost proof
    var j: Int := n
    while (j > 0)
        //TOSEQ: invariant sortedRows(m)
        invariant access_matrix_frac(m, 1/2)
        invariant j >= 0 && j <= dim(m)
        invariant repByRows(m, j, 0) == old[before1](repByRows(m, j, 0))
        invariant forall i:Int :: { repRow(m, i, 0) } i >= 0 && i < dim(m) ==> repRow(m, i, 0) == old[before1](repRow(m, i, 0))
    {
        j := j - 1
    }

    var n_min_zeros: Int
    var n_min_ones: Int
    //TOSEQ: n_min_zeros, n_min_ones := proofPart1(m, k, 1 / 4)

    //TOSEQ: assert n_min_zeros + n_min_ones >= (dim(m) - 1) / 2
    //TOSEQ: assert forall col:Int :: { numbersOfElemsCol(S, col, k, 0, 0) } col >= 0 && col < dim(m) ==> numbersOfElemsCol(S, col, k, 0, dim(m) - 1) >= n_min_zeros
    //TOSEQ: assert forall col:Int :: { numbersOfElemsCol(S, col, k, 1, 0) } col >= 0 && col < dim(m) ==> numbersOfElemsCol(S, col, k, 1, dim(m) - 1) >= n_min_ones


    /*
    requires p > none
    requires access_matrix_frac(m, p)
    requires sortedRows(m)
    
    ensures access_matrix_frac(m, p)
    
    ensures n_min_zeros + n_min_ones >= (dim(m) - 1) / 2
    ensures forall col:Int :: { numbersOfElemsCol(S, col, k, 0, 0) } col >= 0 && col < dim(m) ==> numbersOfElemsCol(S, col, k, 0, dim(m) - 1) >= n_min_zeros
    ensures forall col:Int :: { numbersOfElemsCol(S, col, k, 1, 0) } col >= 0 && col < dim(m) ==> numbersOfElemsCol(S, col, k, 1, dim(m) - 1) >= n_min_ones
*/
    
    // counting rows idea:
    //var asColRow : Seq[Seq[Int]] := asColRowSeqSeq(m)
    //var fewestLtK : Int := colmin_lt(m,asColRow,k)
    //var fewestGtK : Int := colmin_gt(m,asColRow,k)
    // (fewestGtk - fewestLtK) * 2 <=  rowsGtK - rowsLessThanK

    assert repByRows(m, 0, 0) == old(repByRows(m, 0, 0))
    helper_lemma(m, 0, 1/2)
    assert repByCols(m, 0, 0) == old(repByCols(m, 0, 0))

    label before2

    // Second inner parallel loop
    exhale forall tid:Int :: { repCol(m, 0, tid) } tid >= 0 && tid < n ==> P2(m, tid)
    inhale forall tid:Int :: { repCol(m, 0, tid) } tid >= 0 && tid < n ==> Q2(m, tid, before2)

    // Ghost proof
    j := n
    while (j > 0)
        invariant access_matrix_frac(m, 1/2)
        invariant j >= 0 && j <= dim(m)
        invariant repByCols(m, 0, j) == old[before2](repByCols(m, 0, j))
        invariant forall i:Int :: { repCol(m, 0, i) } i >= 0 && i < dim(m) ==> repCol(m, 0, i) == old[before2](repCol(m, 0, i))
    {
        j := j - 1
    }

    helper_lemma(m, 0, 1/2)


    p := p + 1
  }
}

method allocMatrix(d:Int) returns (m: NMatrix)
  requires d >= 0
  ensures dim(m) == d
  ensures access_matrix(m)

function two_exponent(n: Int): Int
    ensures n >= 0 ==> result >= 1
    ensures n > 0 ==> result == 2 * two_exponent(n-1)
    ensures n < 0 ==> result == 0
{
    n > 0 ? 2 * two_exponent(n - 1) : (n == 0 ? 1 : 0)
}

// Parallel loops

define P1(m, tid) access_row(m, tid) && tid >= 0 && tid < dim(m)
define Q1(m, tid, lab) access_row(m, tid) && repRow(m, tid, 0) == old[lab](repRow(m, tid, 0))
//TOSEQ:  && rowSorted(S, tid, even(tid))

method first_inner_loop(m: NMatrix, tid: Int)
  requires P1(m, tid)
  ensures access_row(m, tid) && repRow(m, tid, 0) == old(repRow(m, tid, 0))
  //TOSEQ:  && rowSorted(S, tid, even(tid))
{
  sort_row(m, tid, even(tid))
}

define P2(m, tid) access_column(m, tid) && tid >= 0 && tid < dim(m)
define Q2(m, tid, lab) access_column(m, tid) && repCol(m, 0, tid) == old[lab](repCol(m, 0, tid))


method second_inner_loop(m: NMatrix, tid: Int)
  requires P2(m, tid)
  ensures access_column(m, tid) && repCol(m, 0, tid) == old(repCol(m, 0, tid))
{
  sort_column(m, tid)
}

// Specifications

define M(i, j) slot(m,i,j).val // maybe use this in code?

define access_matrix(m) forall i:Int, j:Int :: {slot(m,i,j)} 0 <= i && 0 <= j && i < dim(m) && j < dim(m) ==> acc(slot(m,i,j).val)
define access_matrix_frac(m, p) forall i:Int, j:Int :: {slot(m,i,j)} 0 <= i && 0 <= j && i < dim(m) && j < dim(m) ==> acc(slot(m,i,j).val, p)

define access_row(m, row) forall j:Int :: {slot(m, row,j)} 0 <= j && j < dim(m) ==> acc(slot(m,row,j).val)
define access_row_frac(m, row, p) forall j:Int :: {slot(m, row,j)} 0 <= j && j < dim(m) ==> acc(slot(m,row,j).val, p)

define access_column(m, col) forall i:Int :: {slot(m,i,col)} 0 <= i && i < dim(m) ==> acc(slot(m,i,col).val)
define access_column_frac(m, col, p) forall i:Int :: {slot(m,i,col)} 0 <= i && i < dim(m) ==> acc(slot(m,i,col).val, p)


function repRow(m: NMatrix, row: Int, fromCol: Int): Multiset[Int]
    requires forall j:Int :: {slot(m, row, j)} fromCol <= j && j < dim(m) ==> acc(slot(m, row, j).val, wildcard)
    requires fromCol >= 0 && fromCol <= dim(m)
    requires row >= 0 && row < dim(m)
{
    fromCol < dim(m) ? Multiset(M(row, fromCol)) union repRow(m, row, fromCol + 1) : Multiset()
}

function repByRows(m: NMatrix, fromRow: Int, fromCol: Int): Multiset[Int]
    requires forall i: Int, j:Int :: {slot(m, i, j)} fromCol <= j && j < dim(m) && fromRow <= i && i < dim(m) ==> acc(slot(m, i, j).val, wildcard)
    requires fromCol >= 0 && fromCol <= dim(m)
    requires fromRow >= 0 && fromRow <= dim(m)
{
    fromRow < dim(m) ? repRow(m, fromRow, fromCol) union repByRows(m, fromRow + 1, fromCol) : Multiset()
}

function repCol(m: NMatrix, fromRow: Int, col: Int): Multiset[Int]
    requires forall i:Int :: {slot(m, i, col)} fromRow <= i && i < dim(m) ==> acc(slot(m, i, col).val, wildcard)
    requires fromRow >= 0 && fromRow <= dim(m)
    requires col >= 0 && col < dim(m)
{
    fromRow < dim(m) ? Multiset(M(fromRow, col)) union repCol(m, fromRow + 1, col) : Multiset()
}

function repByCols(m: NMatrix, fromRow: Int, fromCol: Int): Multiset[Int]
    requires forall i: Int, j:Int :: {slot(m, i, j)} fromCol <= j && j < dim(m) && fromRow <= i && i < dim(m) ==> acc(slot(m, i, j).val, wildcard)
    requires fromCol >= 0 && fromCol <= dim(m)
    requires fromRow >= 0 && fromRow <= dim(m)
    ensures fromRow == dim(m) ==> result == Multiset()
{
    fromCol < dim(m) ? repCol(m, fromRow, fromCol) union repByCols(m, fromRow, fromCol + 1) : Multiset()
}

method helper_lemma(m: NMatrix, fromRow: Int, p: Perm)
    requires p > none
    requires forall i: Int, j:Int :: {slot(m, i, j)} 0 <= j && j < dim(m) && fromRow <= i && i < dim(m) ==> acc(slot(m, i, j).val, p)
    requires fromRow >= 0 && fromRow <= dim(m)
    ensures forall i: Int, j:Int :: {slot(m, i, j)} 0 <= j && j < dim(m) && fromRow <= i && i < dim(m) ==> acc(slot(m, i, j).val, p)
    ensures repByCols(m, fromRow, 0) == repByRows(m, fromRow, 0)
{
    if (fromRow < dim(m)) {
        helper_lemma(m, fromRow + 1, p / 2)
        helper_lemma2(m, fromRow, 0, p / 2)
    }
}

method helper_lemma2(m: NMatrix, fromRow: Int, fromCol: Int, p: Perm)
    requires p > none
    requires forall i: Int, j:Int :: {slot(m, i, j)} fromCol <= j && j < dim(m) && fromRow <= i && i < dim(m) ==> acc(slot(m, i, j).val, p)
    requires fromRow >= 0 && fromRow < dim(m)
    requires fromCol >= 0 && fromCol <= dim(m)
    ensures forall i: Int, j:Int :: {slot(m, i, j)} fromCol <= j && j < dim(m) && fromRow <= i && i < dim(m) ==> acc(slot(m, i, j).val, p)
    ensures repByCols(m, fromRow, fromCol) == repRow(m, fromRow, fromCol) union repByCols(m, fromRow + 1, fromCol)
{
    if (fromCol < dim(m)) {
        helper_lemma2(m, fromRow, fromCol + 1, p / 2)
    }
}


function even(i: Int): Bool
{
    i % 2 == 0
}



// SUMMARY

method part1(S: Seq[Seq[Int]], k: Int) returns (n_min_zeros: Int, n_min_ones: Int)
    
    requires squareSeq(S)
    requires sortedRows(S)
        
    ensures n_min_zeros + n_min_ones >= |S| / 2
    ensures forall col:Int :: { numbersOfElemsCol(S, col, k, 0, dd(S)) } col >= 0 && col < |S| ==> numbersOfElemsCol(S, col, k, 0, dd(S)) >= n_min_zeros
    ensures forall col:Int :: { numbersOfElemsCol(S, col, k, 1, dd(S)) } col >= 0 && col < |S| ==> numbersOfElemsCol(S, col, k, 1, dd(S)) >= n_min_ones
    ensures forall col:Int :: { repColSeq(S, 0, col) }  col >= 0 && col < |S| ==> numberOfElemsMulti(repColSeq(S, 0, col), k, 0) >= n_min_zeros
    ensures forall col:Int :: { repColSeq(S, 0, col) }  col >= 0 && col < |S| ==> numberOfElemsMulti(repColSeq(S, 0, col), k, 1) >= n_min_ones
{
    n_min_zeros, n_min_ones := part1_aux(S, k)
    sameAllAux(S, k, 0, 0)
    sameAllAux(S, k, 1, 0)
}

method part2(S: Seq[Seq[Int]], k: Int, n_zeros: Int, n_ones: Int)
    
    requires squareSeq(S)
    requires forall col:Int :: { numbersOfElemsCol(S, col, k, 0, dd(S)) } col >= 0 && col < |S| ==> numbersOfElemsCol(S, col, k, 0, dd(S)) >= n_zeros
    requires forall col:Int :: { numbersOfElemsCol(S, col, k, 1, dd(S)) } col >= 0 && col < |S| ==> numbersOfElemsCol(S, col, k, 1, dd(S)) >= n_ones

    requires sortedCols(S)
    requires n_zeros <= |S|
    requires n_ones <= |S|

    ensures goodRowsOne(S, k, n_ones)
    ensures goodRowsZero(S, k, n_zeros)

{
    if (|S| >= 1) {
        assert numbersOfElemsCol(S, 0, k, 1, dd(S)) <=|S|
        assert n_ones <= numbersOfElemsCol(S, 0, k, 1, dd(S))
        part2_aux_zeros(S, k, n_zeros, 0)
        part2_aux_ones(S, k, n_ones, dd(S))
    }
}




// Second part: Sortedness

function asRowColSeqSeq(m: NMatrix) : Seq[Seq[Int]]
    requires access_matrix_frac(m, wildcard)
    ensures |result| == dim(m) && (forall row:Int , col: Int :: {result[row][col]}{M(row,col)} 
    0 <= row && row < dim(m) ==> 
      |result[row]| == dim(m) && (0 <= col && col < dim(m) ==> result[row][col] == M(row,col)))
// easy to implement if needed

function asColRowSeqSeq(m: NMatrix) : Seq[Seq[Int]]
    requires access_matrix_frac(m, wildcard)
    ensures |result| == dim(m) && (forall col:Int , row: Int :: {result[col][row]}{M(row,col)} 0 <= col && col < dim(m) ==> 
      |result[col]| == dim(m) && (0 <= row && row < dim(m) ==> result[col][row] == M(row,col)))
// easy to implement if needed

define squareSeq(S) forall i:Int :: { S[i] } i >= 0 && i < |S| ==> |S[i]| == |S|

function rowSorted(S: Seq[Seq[Int]], row: Int, ascending: Bool): Bool
    requires row >= 0 && row < |S|
    requires squareSeq(S)
{
    forall i:Int, j:Int :: { S[row][i], S[row][j] } 0 <= i && i < j && j < |S| ==> (ascending ? S[row][i] <= S[row][j] : S[row][j] <= S[row][i])
}


function sortedRows(S: Seq[Seq[Int]]): Bool
    requires squareSeq(S)
{
    forall i:Int :: { even(i) } 0 <= i && i < |S| ==> rowSorted(S, i, even(i))
}

function bin(x: Int, k: Int): Int
    ensures result == 0 <==> x <= k
    ensures result == 1 <==> x > k


method rowSortedExistsIndex(S: Seq[Seq[Int]], row: Int, k: Int, ascending: Bool) returns (index: Int)
    requires row >= 0 && row < |S|
    requires squareSeq(S)
    requires rowSorted(S, row, ascending)

    ensures index >= 0 && index <= |S|
    ensures forall i:Int :: { S[row][i] } i >= 0 && i < |S| && i < index ==> (ascending ? bin(S[row][i], k) == 0 : bin(S[row][i], k) == 1)
    ensures forall i:Int :: { S[row][i] } i >= 0 && i < |S| && i >= index ==> (ascending ? bin(S[row][i], k) == 1 : bin(S[row][i], k) == 0)
{
    index := 0
    while (index < |S| && (ascending ? bin(S[row][index], k) == 0 : bin(S[row][index], k) == 1))
        invariant index >= 0 && index <= |S|
        invariant forall i:Int :: { S[row][i] } i >= 0 && i < |S| && i < index ==> (ascending ? bin(S[row][i], k) == 0 : bin(S[row][i], k) == 1)
    {
        index := index + 1
    }
    var j: Int := index
    while (j < |S|)
        invariant j >= index && j <= |S|
        invariant forall i:Int :: { S[row][i] } i >= 0 && i < j && i >= index ==> (ascending ? bin(S[row][i], k) == 1 : bin(S[row][i], k) == 0)
    {
        j := j + 1
    }
}

method combineTwoRowsAux(S: Seq[Seq[Int]], r1: Int, r2: Int, k: Int, i1: Int, i2: Int, b: Int, from: Int)

    requires squareSeq(S)

    requires r1 >= 0 && r1 < |S|
    requires r2 >= 0 && r2 < |S|
    requires rowSorted(S, r1, true)
    requires rowSorted(S, r2, false)
    requires from >= 0 && from <= |S|

    requires forall i:Int :: { S[r1][i] } i >= 0 && i < |S| && i < i1 ==> bin(S[r1][i], k) == 0
    requires forall i:Int :: { S[r1][i] } i >= 0 && i < |S| && i >= i1 ==> bin(S[r1][i], k) == 1

    requires forall i:Int :: { S[r2][i] } i >= 0 && i < |S| && i < i2 ==> bin(S[r2][i], k) == 1
    requires forall i:Int :: { S[r2][i] } i >= 0 && i < |S| && i >= i2 ==> bin(S[r2][i], k) == 0

    requires b == 0 <==> i1 >= i2
    requires b == 1 <==> i1 < i2


    ensures forall i:Int :: { S[r1][i] } { S[r2][i] }  i >= from && i < |S| ==> (bin(S[r1][i], k) == b || bin(S[r2][i], k) == b)
{
    if (from < |S|) {
        combineTwoRowsAux(S, r1, r2, k, i1, i2, b, from + 1)
    }
}

method combineTwoRows(S: Seq[Seq[Int]], r1: Int, r2: Int, k: Int) returns (b: Int)
    requires squareSeq(S)

    requires r1 >= 0 && r1 < |S|
    requires r2 >= 0 && r2 < |S|
    requires rowSorted(S, r1, true)
    requires rowSorted(S, r2, false)

    ensures forall i:Int :: { S[r1][i] } { S[r2][i] }  i >= 0 && i < |S| ==> (bin(S[r1][i], k) == b || bin(S[r2][i], k) == b)
{
    var i1: Int
    i1 := rowSortedExistsIndex(S, r1, k, true)
    var i2: Int
    i2 := rowSortedExistsIndex(S, r2, k, false)

    if (i1 >= i2) {
        b := 0
    }
    else {
        b := 1
    }

    combineTwoRowsAux(S, r1, r2, k, i1, i2, b, 0)

}

function numberOfElemsMulti(r: Multiset[Int], k: Int, b: Int): Int
    ensures |r| == 0 ==> result == 0
    //ensures forall ra:Multiset[Int], rb:Multiset[Int] :: { ra union rb } r == ra union rb ==> result == numberOfElemsMulti(ra, k, b) + numberOfElemsMulti(rb, k, b)
    ensures forall x:Int :: { x in r } (x in r) >= 1 ==> result == b2i(bin(x, k) == b) + numberOfElemsMulti(r setminus Multiset(x), k, b)

function b2i(b: Bool): Int
    ensures result == 0 <==> !b
    ensures result == 1 <==> b
    ensures result >= 0
{
    b ? 1 : 0
}

// Returns the set of rows in which at the column col we have a b for bin(k, b)
function numbersOfElemsCol(S: Seq[Seq[Int]], col: Int, k: Int, b: Int, toRow: Int): Int
    requires squareSeq(S)
    requires toRow >= -1 && toRow < |S|
    requires col >= 0 && col < |S|
    ensures toRow >= 0 ==> result >= numbersOfElemsCol(S, col, k, b, toRow - 1)
    ensures result <= toRow + 1

{
    toRow == -1 ? 0 : (b2i(bin(S[toRow][col], k) == b) + numbersOfElemsCol(S, col, k, b, toRow - 1))
}

// Returns the set of rows in which at the column col we have a b for bin(k, b)
function numbersOfElemsColInv(S: Seq[Seq[Int]], col: Int, k: Int, b: Int, fromRow: Int): Int
    requires squareSeq(S)
    requires fromRow >= 0 && fromRow <= |S|
    requires col >= 0 && col < |S|
    ensures result + numbersOfElemsCol(S, col, k, b, fromRow - 1) == numbersOfElemsCol(S, col, k, b, |S| - 1) 
    ensures result <= |S| - fromRow
{
    fromRow == |S| ? 0 : (b2i(bin(S[fromRow][col], k) == b) + numbersOfElemsColInv(S, col, k, b, fromRow + 1))
}


function repColSeq(S: Seq[Seq[Int]], fromRow: Int, col: Int): Multiset[Int]
    requires squareSeq(S)
    requires fromRow >= 0 && fromRow <= |S|
    requires col >= 0 && col < |S|
{
    fromRow < |S| ? Multiset(S[fromRow][col]) union repColSeq(S, fromRow + 1, col) : Multiset()
}

// toRow excluded
function repColInv(S: Seq[Seq[Int]], toRow: Int, col: Int): Multiset[Int]
    requires squareSeq(S)
    requires toRow >= 0 && toRow <= |S|
    requires col >= 0 && col < |S|

    ensures toRow > 0 ==> (S[toRow - 1][col] in result) >= 1
    ensures result == repColSeq(S, 0, col) setminus repColSeq(S, toRow, col)
    ensures repColSeq(S, 0, col) == result union repColSeq(S, toRow, col)
{
    toRow == 0 ? Multiset() : Multiset(S[toRow - 1][col]) union repColInv(S, toRow - 1, col)
}

method lemma_two_functions_same_aux(S: Seq[Seq[Int]], col: Int, k: Int, b: Int, toRow: Int)
    requires squareSeq(S)

    requires toRow >= -1 && toRow < |S|
    requires col >= 0 && col < |S|

    
    ensures numbersOfElemsCol(S, col, k, b, toRow) == numberOfElemsMulti(repColInv(S, toRow + 1, col), k, b)
{
    if (toRow >= 0) {
        lemma_two_functions_same_aux(S, col, k, b, toRow - 1)
        assert repColInv(S, toRow + 1, col) setminus Multiset(S[toRow][col]) == repColInv(S, toRow, col) // Needed
    }
}

method lemma_two_functions_same(S: Seq[Seq[Int]], col: Int, k: Int, b: Int)
    requires squareSeq(S)
    requires col >= 0 && col < |S|

    
    ensures numbersOfElemsCol(S, col, k, b, |S| - 1) == numberOfElemsMulti(repColSeq(S, 0, col), k, b)
    // repRow(S: Seq[Seq[Int]], row: Int, fromCol: Int): Multiset[Int]
{
    lemma_two_functions_same_aux(S, col, k, b, |S| - 1)
    assert repColInv(S, |S|, col) == repColSeq(S, 0, col)
}





/*
method lemma_two_functions_same_both(S: Seq[Seq[Int]], col: Int, k: Int, p: Perm)

    requires squareSeq(S)
    requires col >= 0 && col < |S|

    
    ensures numbersOfElemsCol(S, col, k, 0, |S| - 1) == numberOfElemsMulti(repColSeq(S, 0, col), k, 0)
    ensures numbersOfElemsCol(S, col, k, 1, |S| - 1) == numberOfElemsMulti(repColSeq(S, 0, col), k, 1)
    */

    // repRow(S: Seq[Seq[Int]], row: Int, fromCol: Int): Multiset[Int]



function dd(S: Seq[Seq[Int]]): Int
    ensures result == |S| - 1
{
    |S| - 1
}

method part1_aux(S: Seq[Seq[Int]], k: Int) returns (n_min_zeros: Int, n_min_ones: Int)
    
    requires squareSeq(S)
    requires sortedRows(S)
        
    ensures n_min_zeros + n_min_ones >= |S| / 2
    ensures forall col:Int :: { numbersOfElemsCol(S, col, k, 0, dd(S)) } col >= 0 && col < |S| ==> numbersOfElemsCol(S, col, k, 0, dd(S)) >= n_min_zeros
    ensures forall col:Int :: { numbersOfElemsCol(S, col, k, 1, dd(S)) } col >= 0 && col < |S| ==> numbersOfElemsCol(S, col, k, 1, dd(S)) >= n_min_ones
{

    n_min_zeros := 0
    n_min_ones := 0
    var row: Int :=  -1

    while (row < |S| - 2)
        invariant sortedRows(S)
        invariant row % 2 == 1
        invariant row >= -1 && row < |S|

        invariant n_min_zeros + n_min_ones >= (row + 1) / 2
        invariant forall col:Int :: { numbersOfElemsCol(S, col, k, 0, row) } col >= 0 && col < |S| ==> numbersOfElemsCol(S, col, k, 0, row) >= n_min_zeros
        invariant forall col:Int :: { numbersOfElemsCol(S, col, k, 1, row) } col >= 0 && col < |S| ==> numbersOfElemsCol(S, col, k, 1, row) >= n_min_ones

//     ensures numbersOfElemsCol(S, col, k, b, |S| - 1) == numberOfElemsMulti(repColSeq(S, 0, col), k, b)

    {
        
        var b: Int

        var r1: Int := row + 1
        var r2: Int := row + 2

        assert even(r1)
        assert !even(r2)

        b := combineTwoRows(S, r1, r2, k)

        if (b == 0) {
            n_min_zeros := n_min_zeros + 1
        }
        else {
            n_min_ones := n_min_ones + 1
        }
        assert forall col:Int :: { numbersOfElemsCol(S, col, k, 0, row) } col >= 0 && col < |S| ==>
            numbersOfElemsCol(S, col, k, 0, r2) == b2i(bin(S[r2][col], k) == 0) + numbersOfElemsCol(S, col, k, 0, r1)

        assert forall col:Int :: { numbersOfElemsCol(S, col, k, 1, row) } col >= 0 && col < |S| ==>
            numbersOfElemsCol(S, col, k, 1, r2) == b2i(bin(S[r2][col], k) == 1) + numbersOfElemsCol(S, col, k, 1, r1)



        row := row + 2

    }

}

method sameAllAux(S: Seq[Seq[Int]], k: Int, b: Int, fromCol: Int)
    
    requires squareSeq(S)
    requires fromCol >= 0 && fromCol <= |S|
        
    ensures forall col:Int :: { repColSeq(S, 0, col) } { numbersOfElemsCol(S, col, k, b, dd(S)) }  col >= fromCol && col < |S| ==> numberOfElemsMulti(repColSeq(S, 0, col), k, b) == numbersOfElemsCol(S, col, k, b, dd(S))
    //ensures forall col:Int :: { repColSeq(S, 0, col) } { numbersOfElemsCol(S, col, k, 1, dd(S)) }  col >= fromCol && col < |S| ==> numberOfElemsMulti(repColSeq(S, 0, col), k, 1) == numbersOfElemsCol(S, col, k, 1, dd(S))
{
    
    if (fromCol < |S|) {
        sameAllAux(S, k, b, fromCol + 1)
        lemma_two_functions_same(S, fromCol, k, b)
    }
}

// PART 2

function colSorted(S: Seq[Seq[Int]], col: Int): Bool
    requires col >= 0 && col < |S|
    requires squareSeq(S)
{
    forall i:Int, j:Int :: { S[i][col], S[j][col] } 0 <= i && i < j && j < |S| ==> S[i][col] <= S[j][col]
}


function sortedCols(S: Seq[Seq[Int]]): Bool
    requires squareSeq(S)
{
    forall i:Int :: { colSorted(S, i) } 0 <= i && i < |S| ==> colSorted(S, i)
}

function goodRow(S: Seq[Seq[Int]], k: Int, zero: Bool, row: Int): Bool
    requires squareSeq(S)
    requires row >= 0 && row < |S|
{
    forall i:Int :: { S[row][i] } 0 <= i && i < |S| ==> (zero ? S[row][i] <= k : S[row][i] > k)
}

function goodRowsZero(S: Seq[Seq[Int]], k: Int, n: Int): Bool
    requires squareSeq(S)
    requires n <= |S|
{
    forall i:Int :: { goodRow(S, k, true, i) } 0 <= i && i < n ==> goodRow(S, k, true, i)
}

function goodRowsOne(S: Seq[Seq[Int]], k: Int, n: Int): Bool
    requires squareSeq(S)
    requires n <= |S|
{
    forall i:Int :: { goodRow(S, k, false, i) } |S| - n <= i && i < |S| ==> goodRow(S, k, false, i)
}

method witness_one(S: Seq[Seq[Int]], k: Int, b: Int, toRow: Int, col: Int) returns (index: Int)
    requires squareSeq(S)
    requires col >= 0 && col < |S|
    requires toRow >= 0 && toRow < |S|
    
    requires numbersOfElemsCol(S, col, k, b, toRow) > 0

    ensures index >= 0 && index <= toRow
    ensures bin(S[index][col], k) == b
{
    assert b2i(bin(S[toRow][col], k) == b) + numbersOfElemsCol(S, col, k, b, toRow - 1) > 0
    if (bin(S[toRow][col], k) == b) {
        index := toRow
    }
    else {
        assert numbersOfElemsCol(S, col, k, b, toRow - 1) > 0
        index := witness_one(S, k, b, toRow - 1, col)
    }
}


method part2_aux_ones(S: Seq[Seq[Int]], k: Int, n: Int, toRow: Int)
    requires squareSeq(S)
    requires toRow >= -1 && toRow < |S|
    requires forall col:Int :: { numbersOfElemsCol(S, col, k, 1, toRow) } col >= 0 && col < |S| ==> numbersOfElemsCol(S, col, k, 1, toRow) >= n
    requires sortedCols(S)
    requires n <= toRow + 1
    requires goodRowsOne(S, k, |S| - toRow - 1)

    ensures goodRowsOne(S, k, n + (|S| - toRow - 1))
{
    if (n > 0) {
        var i: Int := 0
        while (i < |S|)
            invariant i >= 0 && i <= |S|
            invariant forall j:Int :: { S[toRow][j] } 0 <= j && j < i ==> S[toRow][j] > k
        {
            var index: Int
            index := witness_one(S, k, 1, toRow, i)
            assert colSorted(S, i)
            i := i + 1
        }
        var m: Int := toRow - 1
        i := 0
        while (i < |S|)
            invariant i >= 0 && i <= |S|
            invariant forall col:Int :: { numbersOfElemsCol(S, col, k, 1, m) } col >= 0 && col < i ==> numbersOfElemsCol(S, col, k, 1, m) >= n - 1
        {
            assert numbersOfElemsCol(S, i, k, 1, toRow) == (b2i(bin(S[toRow][i], k) == 1) + numbersOfElemsCol(S, i, k, 1, m))
            i := i + 1
        }
        part2_aux_ones(S, k, n - 1, m)
    }
}

method witness_zero(S: Seq[Seq[Int]], k: Int, fromRow: Int, col: Int) returns (index: Int)
    requires squareSeq(S)
    requires col >= 0 && col < |S|
    requires fromRow >= 0 && fromRow < |S|
    
    requires numbersOfElemsColInv(S, col, k, 0, fromRow) > 0

    ensures index >= fromRow && index < |S|
    ensures bin(S[index][col], k) == 0
{
    assert b2i(bin(S[fromRow][col], k) == 0) + numbersOfElemsColInv(S, col, k, 0, fromRow + 1) > 0
    if (bin(S[fromRow][col], k) == 0) {
        index := fromRow
    }
    else {
        assert numbersOfElemsColInv(S, col, k, 0, fromRow + 1) > 0
        index := witness_zero(S, k, fromRow + 1, col)
    }
}
/*

function numbersOfElemsColInv(S: Seq[Seq[Int]], col: Int, k: Int, b: Int, fromRow: Int): Int
    requires squareSeq(S)
    requires fromRow >= 0 && fromRow <= |S|
    requires col >= 0 && col < |S|
    ensures result + numbersOfElemsCol(S, col, k, b, fromRow - 1) == numbersOfElemsCol(S, col, k, b, |S| - 1) 
{
    fromRow == |S| ? 0 : (b2i(bin(S[fromRow][col], k) == b) + numbersOfElemsColInv(S, col, k, b, fromRow + 1))
}
*/

method part2_aux_zeros(S: Seq[Seq[Int]], k: Int, n: Int, fromRow: Int)
    requires squareSeq(S)
    requires fromRow >= 0 && fromRow <= |S|
    requires forall col:Int :: { numbersOfElemsColInv(S, col, k, 0, fromRow) } col >= 0 && col < |S| ==> numbersOfElemsColInv(S, col, k, 0, fromRow) >= n
    requires sortedCols(S)
    requires n + fromRow <= |S|
    requires goodRowsZero(S, k, fromRow)

    ensures goodRowsZero(S, k, fromRow + n)
{
    if (n > 0) {
        var i: Int := 0
        while (i < |S|)
            invariant i >= 0 && i <= |S|
            invariant forall j:Int :: { S[fromRow][j] } 0 <= j && j < i ==> S[fromRow][j] <= k
        {
            var index: Int
            index := witness_zero(S, k, fromRow, i)
            assert colSorted(S, i)
            i := i + 1
        }
        var m: Int := fromRow + 1
        i := 0
        while (i < |S|)
            invariant i >= 0 && i <= |S|
            invariant forall col:Int :: { numbersOfElemsColInv(S, col, k, 0, m) } col >= 0 && col < i ==> numbersOfElemsColInv(S, col, k, 0, m) >= n - 1
        {
            assert numbersOfElemsColInv(S, i, k, 0, fromRow) == (b2i(bin(S[fromRow][i], k) == 0) + numbersOfElemsColInv(S, i, k, 0, m))
            i := i + 1
        }
        part2_aux_zeros(S, k, n - 1, m)
    }
}